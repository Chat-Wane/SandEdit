{
  "name": "smokesignal",
  "version": "0.2.1",
  "description": "Build your own small (or larger) peer to peer network.",
  "keywords": [
    "peers",
    "peer to peer",
    "p2p",
    "gossip",
    "seeds",
    "event passing",
    "distributed",
    "cluster",
    "scaling",
    "scale",
    "stream",
    "streams"
  ],
  "main": "index.js",
  "dependencies": {
    "netmask": "*",
    "nssocket": "*"
  },
  "author": {
    "name": "marcelklehr",
    "email": "mklehr@gmx.net",
    "url": "Marcel Klehr"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/marcelklehr/smokesignal.git"
  },
  "license": "MIT",
  "readme": "# ![smokesignal](https://raw.github.com/marcelklehr/smokesignal/develop/smokesignal.png)\r\n\r\nScale your real-time app with p2p message passing.\r\n\r\n* *Simple*: Broadcast stuff or just speak to a specific peer.\r\n* *Autonomic*: Have your nodes gather and reorder automatically.\r\n* *Flexible*: You define, how your nodes will behave.\r\n* *Self-healing*: Auto-detection of netsplits and disconnect events.\r\n\r\nSmokesignal is not a gossip protocol. It does not implement p2p data replication for you. It is a plain, flexible peer-to-peer networking solution, onto which you can easily build your own replication model or use some event passing mechanism.\r\n\r\nTo faciliate this, direct connections from peer to peer as well as a network-wide broadcast (`Node.broadcast`) are simple duplex streams. Thus you can add all favours of stream-goodness, like [remote-events](https://github.com/dominictarr/remote-events), [p2p-rpc-stream](https://github.com/marcelklehr/p2p-rpc-stream), and [what not](https://github.com/substack/stream-handbook#read-more).\r\n\r\nYou can connect to new peers manually or allow your node to search for peers automatically. You can listen on peer list events to get notified when your node added or removed a peer.\r\nIf you want, your node will automatically ping the network seed(s) once in a while, to detect netsplits and resolve them automatically. \r\nNodes emit a `connect` event when the node adds the first peer, and a `disconnect` event, when the last peer disconnects. If you have specified some seeds, your node will automatically rejoin the network in this case.\r\n\r\nThis project is in development, so be prepared that things might break in some situations.\r\n\r\n```\r\nnpm install smokesignal\r\n```\r\n\r\n## Synopsis\r\n\r\n```js\r\nvar smoke = require('smokesignal')\r\n\r\n\r\nvar node = smoke.createNode({\r\n  port: 8495\r\n, address: smoke.localIp('192.168.2.1/255.255.255.0') // Tell it your subnet and it'll figure out the right IP for you\r\n, seeds: [{port: 13, address:'192.168.2.100'}] // the address of a seed (a known node)\r\n})\r\n\r\n// listen on network events...\r\n\r\nnode.on('connect', function() {\r\n  // Hey, now we have at least one peer!\r\n  \r\n  // ...and broadcast stuff -- this is an ordinary duplex stream!\r\n  node.broadcast.write('HEYO! I\\'m here')\r\n})\r\n\r\nnode.on('disconnect', function() {\r\n  // Bah, all peers gone.\r\n})\r\n\r\n// Broadcast is a stream\r\nprocess.stdin.pipe(node.broadcast).pipe(process.stdout)\r\n\r\n// Start the darn thing\r\nnode.start()\r\n\r\n// mah, i'd rather stop it\r\nnode.stop()\r\n```\r\n\r\nCheck out the complete [chat app example](https://github.com/marcelklehr/smokesignal/tree/develop/example/ChatApp)!\r\n\r\n## API\r\n\r\n### smoke.createNode(opts:object)\r\nCreates a new node.\r\nOptions:\r\n\r\n * `address`: (compulsory) Your current ip address\r\n * `port`: (compulsory) Port to bind at\r\n * `minPeerNo`: (optional; default: 3) how many peers this node will actively try to bond with -- you can always connect to more manually!\r\n * `maxPeerNo: (optional; default: 5) how many peers this node will accept at max. Infinity for no limit\r\n * `seeds`: (optional) an array of known nodes, that are part of the network, e.g. `{port: 0, address: '127.0.0.1'}`\r\n * `pingTimeout`: (optional; default: 3000)  The time span in ms after which we consider the ping as failed\r\n * `logger`: (optional; default: empty object) An object that may provide the following methods: trace, debug, info, warn, error, fatal\r\n\r\n### Class: Node\r\n\r\n#### Event: connect\r\nEmitted when we have at least one peer.\r\n\r\n#### Event: disconnect\r\nEmitted when the last peer disconnects.\r\n\r\n#### Node#broadcast\r\nA duplex stream. Everyone will get what you write to it, and you'll get everything other people write to it also here.\r\n\r\n#### Node#start()\r\nStarts the node. The tcp server will be bound to the specified port and the node will try to enter the network.\r\n\r\n#### Node#stop()\r\nStops the node. Will disconnect all peers and shut down the tcp server.\r\n\r\n#### Node#addPeer(address:string, port:int)\r\nTries to connect to the node at the specified address and add it as a peer.\r\nThis should allow people to pass a callback..\r\n\r\n#### Node#peerlist\r\nAn instance of `Peerlist`\r\n\r\n### Class: Peerlist\r\n\r\n#### Event: add\r\nEmitted when a peer is added. This event is triggered with the corresponding peer object as the first parameter.\r\n\r\n#### Event: remove\r\nEmitted when a peer is removed. This event is triggered with the corresponding peer object as the first parameter.\r\n\r\n#### Peerlist#inList(my_peer:Peer)\r\nReturns a boolean indicating whether you're currently friends with that peer.\r\n\r\n#### Peerlist#list\r\nAn array containing all nodes you're friends with. Please don't manipulate this directly. Instead, use Node#addPeer to try and connect to a node and Peer#close\r\n\r\n### Class: Peer\r\nA duplex stream. Write something to it and the other end will get it out of their representational Peer object for your node. Vice versa, if the other side writes something to their object, you'll be able read it here.\r\n\r\n#### Event: end\r\nEmitted when all ties to this node have been cut.\r\n\r\n#### Peer#remoteAddress\r\nThe remote address of this peer.\r\n\r\n#### Peer#remotePort\r\nThe remote port of this peer.\r\n\r\n#### Peer#id\r\nThe network-wide id of this peer.\r\n\r\n#### Peer#close\r\nCut's everything that ties you to this node.\r\n\r\n## Todo\r\n\r\n * Use event-loop-friendly nextTick call(back)s\r\n * Maybe make options.port optional, so it just uses an available port\r\n \r\n## Legal\r\n(c) 2012-2013 Marcel Klehr\r\nMIT License\r\n\r\n## Changelog\r\n\r\n0.2.1\r\n * Correctly inherit from EventEmitter\r\n\r\n0.2.0\r\n * Replace socket.io-like interfaces with proper duplex streams\r\n\r\n0.1.0\r\n * Don't depend on log4js",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/marcelklehr/smokesignal/issues"
  },
  "homepage": "https://github.com/marcelklehr/smokesignal",
  "_id": "smokesignal@0.2.1",
  "_from": "smokesignal@"
}
